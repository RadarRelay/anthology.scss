"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Anthology = /** @class */ (function () {
    // --- Constructor --- //
    function Anthology(styleSheet) {
        if (styleSheet === void 0) { styleSheet = Anthology.styleSheets[0]; }
        if (!styleSheet)
            console.log('boop');
        this._stylesheet = styleSheet;
        this.parseMetadata();
    }
    Object.defineProperty(Anthology, "styleSheets", {
        // --- Getters --- //
        /**
         * Get all Anthology-compatible style sheets in the document.
         *
         * @readonly
         * @static
         * @memberof Anthology
         */
        get: function () {
            // TODO: memoize
            var styleSheets = Array.from(document.styleSheets);
            return styleSheets.filter(function (rawSheet) {
                if (!rawSheet['rules'] && !rawSheet['cssRules'])
                    return false;
                var cssSheet = rawSheet;
                var rules = Array.from(cssSheet.rules || cssSheet.cssRules);
                return !!rules.find(function (rule) { return rule.selectorText === '-anthology-metadata::before'; });
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Anthology.prototype, "breakpoints", {
        /**
         * Get the breakpoints configured for this instance of `Anthology.scss`.
         *
         * @readonly
         * @type {{ [key in BreakpointNames]: string }}
         * @memberof Anthology
         */
        get: function () {
            return this._metadata.config.breakpoints;
        },
        enumerable: true,
        configurable: true
    });
    // --- Methods --- //
    /**
     * Parses metadata for this instance of `Anthology.scss`.
     */
    Anthology.prototype.parseMetadata = function () {
        // TODO: better error messaging
        if (!this._stylesheet['cssRules']) {
            throw new Error('Style sheet does not contain any CSS rules.');
        }
        var cssSheet = this._stylesheet;
        var rules = Array.from(cssSheet.rules || cssSheet.cssRules);
        var metadataRule = rules.find(function (rule) {
            return rule.selectorText === '-anthology-metadata::before';
        });
        if (!metadataRule) {
            throw new Error('Style sheet does not contain Anthology.scss metadata.');
        }
        var metadata = JSON.parse(JSON.parse(metadataRule.style.content));
        this._metadata = metadata;
        this._rules = rules;
        return this;
    };
    /**
     * Extract the `style` object from a `CSSRule` generated by `Anthology.scss`.
     *
     * @param shorthand
     * @param adjective
     * @param options
     */
    Anthology.prototype.extract = function (shorthand, adjective, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        // TODO: memoize and improve comments
        var separator = this._metadata.config.separator;
        var importantTag = this._metadata.config['important-tag'];
        var themeTag = this._metadata.config['theme-tag'];
        var responsiveTag = this._metadata.config['responsive-tag'];
        var important = !!options.important ? "" + separator + importantTag : '';
        var theme = !!options.theme ? "" + separator + themeTag + options.theme : '';
        var breakpoint = !!options.breakpoint ? "" + separator + responsiveTag + options.breakpoint : '';
        var pseudo = !!options.pseudo ? "" + separator + options.pseudo : '';
        var styleRule;
        // Find the first matching CSS Rule
        this._rules.find(function (rule) {
            // Search dynamically-responsive rules first
            if (!!options.breakpoint && rule.type === CSSRule.MEDIA_RULE) {
                var mediaRule = rule;
                if (mediaRule.conditionText.includes(_this.breakpoints[options.breakpoint])) {
                    var selector_1 = CSS.escape("" + shorthand + separator + adjective + important + theme + pseudo);
                    return !!Array.from(mediaRule.cssRules).find(function (rule) {
                        styleRule = rule;
                        return styleRule.selectorText.includes(selector_1);
                    });
                }
                ;
            }
            else if (rule.type === CSSRule.STYLE_RULE) {
                var selector = CSS.escape("" + shorthand + separator + adjective + important + theme + breakpoint + pseudo);
                styleRule = rule;
                return styleRule.selectorText.includes(selector);
            }
        });
        return styleRule.style;
    };
    return Anthology;
}());
exports.Anthology = Anthology;
