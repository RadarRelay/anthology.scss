import { ExtractOptions } from './types';

export class AnthologyClient<BreakpointNames extends string> {
  // --- Properties --- //

  private _metadata: any;
  private _stylesheet: StyleSheet;
  private _rules: CSSRule[];

  // --- Constructor --- //

  constructor(styleSheet: StyleSheet = AnthologyClient.styleSheets[0]) {
    if (!styleSheet) console.log('boop');
    this._stylesheet = styleSheet;
    this.parseMetadata();
  }

  // --- Getters --- //

  /**
   * Get all Anthology-compatible style sheets in the document.
   *
   * @readonly
   * @static
   * @memberof Anthology
   */
  public static get styleSheets() {
    // TODO: memoize
    const styleSheets = Array.from(document.styleSheets);

    return styleSheets.filter(rawSheet => {
      if (!rawSheet['rules'] && !rawSheet['cssRules']) return false;
      const cssSheet = rawSheet as CSSStyleSheet;
      const rules = Array.from(cssSheet.rules || cssSheet.cssRules) as unknown as CSSStyleRule[];
      return !!rules.find(rule => rule.selectorText === '-anthology-metadata::before');
    });
  }

  /**
   * Get the breakpoints configured for this instance of `Anthology.scss`.
   *
   * @readonly
   * @type {{ [key in BreakpointNames]: string }}
   * @memberof Anthology
   */
  public get breakpoints(): { [key in BreakpointNames]: string } {
    return this._metadata.config.breakpoints;
  }

  // --- Methods --- //

  /**
   * Parses metadata for this instance of `Anthology.scss`.
   */
  public parseMetadata() {
    // TODO: better error messaging
    if (!this._stylesheet['cssRules']) {
      throw new Error('Style sheet does not contain any CSS rules.');
    }

    const cssSheet = this._stylesheet as CSSStyleSheet;
    const rules = Array.from(cssSheet.rules || cssSheet.cssRules) as unknown as CSSRule[];
    const metadataRule: CSSStyleRule = rules.find(rule => {
      return (rule as CSSStyleRule).selectorText === '-anthology-metadata::before'
    }) as CSSStyleRule;

    if (!metadataRule) {
      throw new Error('Style sheet does not contain Anthology.scss metadata.');
    }

    const metadata = JSON.parse(JSON.parse(metadataRule.style.content));

    this._metadata = metadata;
    this._rules = rules;

    return this;
  }

  /**
   * Extract the `style` object from a `CSSRule` generated by `Anthology.scss`.
   *
   * @param shorthand
   * @param adjective
   * @param options
   */
  public extract(shorthand: string, adjective: string, options: ExtractOptions = {}) {
    // TODO: memoize and improve comments
    const separator = this._metadata.config.separator;
    const importantTag = this._metadata.config['important-tag'];
    const themeTag = this._metadata.config['theme-tag'];
    const responsiveTag = this._metadata.config['responsive-tag'];

    const important = !!options.important ? `${separator}${importantTag}` : '';
    const theme = !!options.theme ? `${separator}${themeTag}${options.theme}` : '';
    const breakpoint = !!options.breakpoint ? `${separator}${responsiveTag}${options.breakpoint}` : '';
    const pseudo = !!options.pseudo ? `${separator}${options.pseudo}` : '';

    let styleRule: CSSStyleRule;

    // Find the first matching CSS Rule
    this._rules.find(rule => {

      // Search dynamically-responsive rules first
      if (!!options.breakpoint && rule.type === CSSRule.MEDIA_RULE) {
        const mediaRule = rule as CSSMediaRule
        if (mediaRule.conditionText.includes(this.breakpoints[options.breakpoint])) {
          const selector = CSS.escape(`${shorthand}${separator}${adjective}${important}${theme}${pseudo}`);

          return !!Array.from(mediaRule.cssRules).find(rule => {
            styleRule = rule as CSSStyleRule;
            return styleRule.selectorText.includes(selector);
          });
        };
      }
      else if (rule.type === CSSRule.STYLE_RULE) {
        const selector = CSS.escape(`${shorthand}${separator}${adjective}${important}${theme}${breakpoint}${pseudo}`);

        styleRule = rule as CSSStyleRule;
        return styleRule.selectorText.includes(selector);
      }

    });

    return styleRule.style;
  }
}
