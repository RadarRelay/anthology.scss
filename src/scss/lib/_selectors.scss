// Generates a raw selector string.
@function _anthology-raw-selector($shorthand, $adjective, $options)
{
  // Get config properties
  $sep: _A(get-var, ('config', 'separator'));
  $imp-tag: _A(get-var, ('config', 'important-tag'));
  $theme-tag: _A(get-var, ('config', 'theme-tag'));
  $res-tag: _A(get-var, ('config', 'responsive-tag'));

  // $options should already be normalized with `_anthology-single-selector-options(...)` by this point.
  // Unpack options
  $breakpoint: A(map-get, $options, 'breakpoint');
  $theme: A(map-get, $options, 'theme');
  $pseudo: A(map-get, $options, 'pseudo');
  $important: A(map-get, $options, 'important');

  // Build the resulting selector
  $result: '#{$shorthand}#{$sep}#{$adjective}';

  @if $important
  {
    $with-important: '#{$imp-tag}';
    $result: '#{$result}#{$sep}#{$with-important}';
  }

  @if $theme
  {
    $with-theme: '#{$theme-tag}#{$theme}';
    $result: '#{$result}#{$sep}#{$with-theme}';
  }

  @if $breakpoint
  {
    $with-breakpoint: '#{$res-tag}#{$breakpoint}';
    $result: '#{$result}#{$sep}#{$with-breakpoint}';
  }

  @if $pseudo
  {
    @if not A(str-starts-with, $pseudo, ':') and not A(str-starts-with, $pseudo, '::')
    {
      @error '[anthology::raw-selector] --- Expected a pseudo-class or pseudo-element, received `#{$pseudo}`.';
    }

    $with-pseudo: '\\\\#{$pseudo}';
    $result: '#{$result}#{$sep}#{$with-pseudo}';
  }

  @return $result;
}

// Generates a usable selector that targets themes and pseudo-elements/pseudo-classes.
@function _anthology-compound-selector($shorthand, $adjective, $options, $silent)
{
  $theme-attr: _A(get-var, ('config', 'theme-attr'));

  // Merge default options
  $options: _A(single-selector-options, $options);

  // Unpack options
  $breakpoint: A(map-get, $options, 'breakpoint');
  $theme: A(map-get, $options, 'theme');
  $pseudo: A(map-get, $options, 'pseudo');
  $important: A(map-get, $options, 'important');

  // Build raw selector
  $theme-designation-selector: '[#{$theme-attr}~="#{$theme}"]';
  $raw-selector: _A(raw-selector, $shorthand, $adjective, $options);

  $result: if(
    $silent,
    '%#{$raw-selector}',
    '.#{$raw-selector}',
  );

  @if $theme
  {
    @if $pseudo
    {
      $result: '#{$theme-designation-selector} #{$result}#{$pseudo}, #{$result}#{$theme-designation-selector}#{$pseudo}';
    }
    @else
    {
      $result: '#{$theme-designation-selector} #{$result}, #{$result}#{$theme-designation-selector}';
    }
  }
  @else if $pseudo
  {
    $result: '#{$result}#{$pseudo}';
  }

  $result: A(stringify, $result);

  @return $result;
}

// Generates all combinations of class attribute selectors for the given arguments.
@function _anthology-full-selector($shorthand, $adjective, $property, $value, $breakpoint, $pseudos, $themes, $important, $silent)
{
  $result: _A(compound-selector, $shorthand, $adjective, ('important': $important, 'breakpoint': $breakpoint), $silent);

  @if $pseudos
  {

    @each $pseudo in $pseudos
    {

      // pseudo + theme
      @if $themes
      {
        @each $theme in $themes
        {
          $selector: _A(compound-selector, $shorthand, $adjective, ('theme': $theme, 'pseudo': $pseudo, 'important': $important, 'breakpoint': $breakpoint), $silent);
          @if not A(str-contains, $result, $selector)
          {
            $result: '#{$result}, #{$selector}';
          }
        }
      }

      // pseudo only
      $selector: _A(compound-selector, $shorthand, $adjective, ('pseudo': $pseudo, 'important': $important, 'breakpoint': $breakpoint), $silent);
      @if not A(str-contains, $result, $selector)
      {
        $result: '#{$result}, #{$selector}';
      }
    }
  }

  @if $themes
  {
    // theme only
    @each $theme in $themes
    {
      $selector: _A(compound-selector, $shorthand, $adjective, ('theme': $theme, 'important': $important, 'breakpoint': $breakpoint), $silent);
      @if not A(str-contains, $result, $selector)
      {
        $result: '#{$result}, #{$selector}';
      }
    }
  }

  @return $result;
}
